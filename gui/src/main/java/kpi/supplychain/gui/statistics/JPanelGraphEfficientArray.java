/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package kpi.supplychain.gui.statistics;


import kpi.supplychain.pojo.NetworkConfig;

import static java.awt.Color.*;
import java.awt.Graphics;
import java.util.List;

/**
 *
 * @author I
 */
public class JPanelGraphEfficientArray extends javax.swing.JPanel {

    private List<NetworkConfig> nConfigList;

    private double[] networkDegree;
    
    private int highligt=-1;
    private int mouseX;
    private int mouseY;
    private int mouseSelected;
    private int scale = 0;
    private int xShift=0;
    private int yShift=0;
       /**
     * Creates new form JPanelGraph
     */
    public JPanelGraphEfficientArray() {
        initComponents();
    }

    public List<NetworkConfig> getnConfigList() {
        return nConfigList;
    }

    public void setnConfigList(List<NetworkConfig> nConfigList) {
        this.nConfigList = nConfigList;
    }

    public int getHighligt() {
        return highligt;
    }

    public void setHighligt(int highligt) {
        this.highligt = highligt;
    }

    public int getMouseX() {
        return mouseX;
    }

    public void setMouseX(int mouseX) {
        this.mouseX = mouseX;
    }

    public int getMouseY() {
        return mouseY;
    }

    public void setMouseY(int mouseY) {
        this.mouseY = mouseY;
    }

    public int getMouseSelected() {
        return mouseSelected;
    }

    public void setMouseSelected(int mouseSelected) {
        this.mouseSelected = mouseSelected;
    }

    public int getScale() {
        return scale;
    }

    public void setScale(int sclae) {
        this.scale = sclae;
    }

    public int getxShift() {
        return xShift;
    }

    public void setxShift(int xShift) {
        this.xShift = xShift;
    }

    public int getyShift() {
        return yShift;
    }

    public void setyShift(int yShift) {
        this.yShift = yShift;
    }

 
    
   

    public double[] getNetworkDegree() {
        return networkDegree;
    }

    public void setNetworkDegree(double[] networkDegree) {
        this.networkDegree = networkDegree;
    }

    

    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables


    private double minCost(){
        double min=nConfigList.get(0).getTotalCost();
        for (int i = 0; i<nConfigList.size(); i++)
            if(nConfigList.get(i).getTotalCost()<min) min=nConfigList.get(i).getTotalCost();
        return min;
    }
    
    private double maxCost(){
        double max=nConfigList.get(0).getTotalCost();
        for (int i = 0 ; i < nConfigList.size(); i++)
            if (nConfigList.get(i).getTotalCost()>max) max=nConfigList.get(i).getTotalCost();
        return max;
    }
    
    private double minDegree(){
        double min = networkDegree[0];
        for (int i = 0 ; i < networkDegree.length; i++)
            if(networkDegree[i]<min) min=networkDegree[i];
        return min;
    }

    private double maxDegree(){
        double max = networkDegree[0];
        for (int i = 0 ; i < networkDegree.length; i++)
            if(networkDegree[i]>max) max=networkDegree[i];
        return max;
    }

    @Override
    protected void paintComponent(Graphics g) {
        int width = getWidth();
        int height = getHeight();
        g.setColor(white);
        g.fillRect(0, 0, width, height);
         

        double xMax=100, xMin=1, yMax=1000, yMin=10;
        if(networkDegree!=null){
            xMax=maxDegree()*100+5;
                    xMin=minDegree()*100-2;  
                    yMin=minCost()-120000; 
                    yMax=maxCost()+50000;
        }
       
        double xScale = width / (xMax - xMin)+scale;
        double yScale = height / (yMax - yMin)+scale;
        int x0 = (int)(-xMin * xScale)+30-xShift;
        int y0 = (int)(yMax * yScale)-yShift;
        
        // Сітка:
        double xStep = 1; // Крок сітки
        for (double dx = xStep; dx < xMax; dx += xStep) {
            int x = x0 + (int)(dx * xScale);
            g.setColor(lightGray);
            g.drawLine(x, 0, x, height);
            g.setColor(black);
            g.drawString((int)dx + "", x + 2, height-5);
        }
        for (double dx = -xStep; dx >= xMin; dx -= xStep) {
            int x = x0 + (int)(dx * xScale);
            g.setColor(lightGray);
            g.drawLine(x, 0, x, height);
            g.setColor(black);
            g.drawString((int)dx + "", x + 2, 10);
        }
        
        double yStep = 1;
        while (yStep * yScale < 20)
            yStep *= 10;
        for (double dy = yStep; dy < yMax; dy += yStep) {
            int y = y0 - (int)(dy * yScale);
            g.setColor(lightGray);
            g.drawLine(0, y, width, y);
            g.setColor(black);
            g.drawString(dy + "", 2, y - 2);
            }
        for (double dy = -yStep; dy > yMin; dy -= yStep) {
            int y = y0 - (int)(dy * yScale);
            g.setColor(lightGray);
            g.drawLine(0, y, width, y);
            g.setColor(black);
            g.drawString(dy + "", 2, y - 2);
        }
        
        if(networkDegree!=null){
        for (int i = 0; i < networkDegree.length; i++) {
            int x = x0 + (int)(networkDegree[i]*100 * xScale-17);
            int y = y0 - (int)(nConfigList.get(i).getTotalCost() * yScale);
            
            if( (i==highligt))
                    
                    {
                g.setColor(red);
                g.fillOval(x-4, y-4, 10, 10);
                g.setColor(blue);
                g.drawOval(x-4, y-4, 10, 10);
                g.setColor(orange);
                g.clearRect(x+10, y+2, 130, 80);
                g.fillRect(x+10, y+2, 130, 80);
                g.setColor(black);
                g.drawString("№ конфигурации:"+(i+1), x+15, y+20);
                g.drawString("Затраты:"+nConfigList.get(i).getTotalCost(), x+15, y+40);
                g.drawString("Сервис:"+String.format("%.5g%n", networkDegree[i]*100), x+15, y+60);
                
            }
            else if (( (Math.abs(x-mouseX)<=2)&&(Math.abs(y-mouseY)<=2))){
                g.setColor(red);
                g.fillOval(x-4, y-4, 10, 10);
                g.setColor(blue);
                g.drawOval(x-4, y-4, 10, 10);
                g.setColor(orange);
                g.clearRect(x+10, y+2, 130, 80);
                g.fillRect(x+10, y+2, 130, 80);
                g.setColor(black);
                g.drawString("№ конфигурации:"+(i+1), x+15, y+20);
                g.drawString("Затраты:"+nConfigList.get(i).getTotalCost(), x+15, y+40);
                g.drawString("Сервис:"+String.format("%.5g%n", networkDegree[i]*100), x+15, y+60);
                this.mouseSelected=i;
                this.highligt=-1;
            }
            else  {
                
                g.setColor(yellow);
                g.fillOval(x-2, y-2, 5, 5);
                g.setColor(blue);
                g.drawOval(x-2, y-2, 5, 5);


            }
            
//            
            
            
        }

        }

      }
}





